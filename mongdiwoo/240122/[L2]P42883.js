// P42883 : 큰 수 만들기
// 주어진 숫자 문자열에서

/*
그리디
- 문제 한 단계마다 최적의 선택을 한다!
*/

/*
    이전에 내가 쓴 방법은 주어진 문자열의 순서는 그대로 한 문자씩 돌면서 그 다음에 현재 숫자보다 큰 숫자가 있는지 비교하는 방식이었다.
    하지만 이 방법으로는 어림도 없었고.. 
    최대 숫자만 골라서 남기기? 최소 숫자만 골라서 삭제하기?
    다 예제 3번에서는 막혔다..^^
    결국 하나씩 모든 경우의 수를 내야 하나? 싶었는데 그렇게 되면 삭제하는 숫자가 많아질수록 계산이 늘어나서 시간초과가 날게 분명했다. 
    암튼 며칠을 고민하다가 결국 인터넷의 힘을 빌렸고,,, 

    한 줄씩 뜯어서 이해하는 걸로 공부하려고 한다. 하하
*/
function solution(number, k) {
    // 스택을 사용해 최댓값에 들어갈 숫자를 빼고 더하면서 계산한다.
    // => 즉, 나는 기존 number에서 필요없는 숫자를 빼는 방식으로 접근했었고, 이 방식은 number 숫자를 기반으로 새로운 스택을 사용해 큰 수를 만들어간다.
    let stack = [];

    // 주어진 number는 하나씩 순회한다.
    for (let i = 0; i < number.length; i++) {
        // 현재 검사할 숫자 하나를 뺀다.
        let current = number[i];

        // while문 검사 조건
        // 1. 제거해야 할 숫자 개수가 남았을 때
        // 2. 스택이 비어있지 않을 때
        // 3. 스택의 마지막 숫자가 현재 숫자보다 작을 때
        // => 현재 숫자가 스택의 마지막 숫자보다 크다면 스택의 마지막 숫자를 삭제한다!
        while (k > 0 && stack.length > 0 && stack[stack.length - 1] < current) {
            stack.pop();
            k--;
        }

        // 현재 숫자가 스택의 마지막 숫자보다 작다면 스택의 마지막에 추가된다.
        // 스택의 마지막 숫자보다 큰 숫자가 들어간다면, 그 순간부터는 k(삭제할 개수)를 초과한 것이다.
        stack.push(current);
    }

    // 남은 k가 있다면 뒷자리에서 제거
    // => 뒷자리 숫자가 클수록 큰 수기 때문이다.
    stack.splice(stack.length - k, k);

    // 스택의 모든 숫자를 하나의 문자열로 묶으면 답이 된다.
    const answer = stack.join("");
    return answer;
}

console.log(solution("4177252841", 4));
